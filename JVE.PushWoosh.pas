(**************************************************************************)
(* JVEsoft Cross Platform Infrastructure Component Suite                  *)
(* Copyright (C) 2013-2017 JVEsoft ltd. All Rights Reserved               *)
(*                                                                        *)
(* This file is subject to the terms and conditions defined in file       *)
(* 'Manual.pdf', section License Agreement, which is part of this         *)
(* source code package.                                                   *)
(**************************************************************************)

unit JVE.PushWoosh;

interface

uses System.SysUtils, System.Classes, System.SyncObjs, System.Sensors, JVE.Utils,
  System.StrUtils, JVE.Configuration, JVE.Pushes, JVE.OpenURL;

// This class implements PushWoosh interface for push notifications. Notice,
// it only supports iOS and Mac OS X platforms.
// PushWoosh custom "Page" pushes are not supported, only the standard ones.
//
// Go to www.pushwoosh.com for more information and to register an app.
//
// This class can also be used as an example of implementation for other push
// notification providers: the important thing is to implement DoToken function.
type
  TJVEPushWooshTagType = (ttList, ttString, ttInteger);
  TJVEPushWooshSend = (psOpen, psRegister, psTags, psLocation, psStat);
  TJVEPushWooshSends = set of TJVEPushWooshSend;

  TJVEPushWooshData = class helper for TJVEPushData
    function GetLink: String;
    function GetHash: String;
    function GetCustomData: String;
  end;

  [ComponentPlatformsAttribute($000B945F)]
  TJVEPushWoosh = class(TJVEPushNotification)
  private
    FToken, FHash: String;
    FToSend: TJVEPushWooshSends;
    FProtected: TCriticalSection;
    FApplicationCode: String;
    function GetTagInteger(Name: String): Integer;
    function GetTagList(Name: String): TArray<String>;
    function GetTagString(Name: String): String;
    function GetUserLocation: TLocationCoord2D;
    procedure SetTagInteger(Name: String; const Value: Integer);
    procedure SetTagList(Name: String; const Value: TArray<String>);
    procedure SetTagString(Name: String; const Value: String);
    procedure SetUserLocation(const Value: TLocationCoord2D);
    procedure UpdateTag(Name: String; Kind: TJVEPushWooshTagType);
    procedure SetApplicationCode(const Value: String);
  protected
    procedure DoToken(Token: String); override;
    procedure DoReceived(Push: TJVEPushData; OnAppStart: Boolean); override;
    procedure PresentPush(Push: TJVEPushData); override;
    procedure Critical(Proc: TProc);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AfterConstruction; override;
    // Notice, Tags and Location are NOT mandatory to use push notifications.
    // If you want to use them, you might need a premium account.

    // The list of tags to be set for the user. Three types of tags are supported
    // by PushWoosh: Integer, String and List of strings. Use an appropriate
    // property to set each tag's value.
    // To create a tag simply set its value; to delete it, call DeleteTag.
    // The values are supposed to be persistent (stored on the PushWoosh server),
    // so they are persisted on the client as well.
    procedure DeleteTag(Name: String);
    property TagList[Name: String]: TArray<String> read GetTagList write SetTagList;
    property TagString[Name: String]: String read GetTagString write SetTagString;
    property TagInteger[Name: String]: Integer read GetTagInteger write SetTagInteger;
    // This is the user location, to be sent to PushWoosh (only supported for iOS).
    property Location: TLocationCoord2D read GetUserLocation write SetUserLocation;
  published
    // This is the application code, generated by PushWoosh. It usually looks
    // like this: XXXXX-XXXXX.
    property ApplicationCode: String read FApplicationCode write SetApplicationCode;
  end;

implementation

{$IF Defined(MACOS)}
uses Macapi.ObjectiveC {$IFDEF IOS}, iOSapi.CocoaTypes, iOSapi.Foundation
  {$ELSE}, Macapi.CocoaTypes, Macapi.Foundation {$ENDIF};
{$ELSEIF Defined(ANDROID)}
uses AndroidApi.JNI.GraphicsContentViewText, AndroidApi.JNIBridge, FMX.Types,
  AndroidApi.JNI.JavaTypes, FMX.Helpers.Android, AndroidApi.Helpers;
{$ENDIF}

{$IF Defined(MACOS) or Defined(ANDROID)}
type
  TPushWooshThread = class(TThread)
  private
    FInstance: TJVEPushWoosh;
    procedure SendLocation;
    procedure SendOpen;
    procedure SendRegister;
    procedure SendStat;
    procedure SendTags;
    function Send(const Command, Params: String): Boolean;
    function Quote(Value: String): String;
  protected
    procedure Execute; override;
  end;

var
  PushWooshThread: TPushWooshThread;
{$ENDIF}
{$IF Defined(MACOS)}
type
  // Redeclared due to a bug in sendSynchronousRequest function's official
  // definition (2nd param there is by value, rather than by reference).
  NSURLConnectionClass = interface(NSObjectClass)
    function sendSynchronousRequest(request: NSURLRequest;
      returningResponse: PPointer; error: PPointer): NSData; cdecl;
  end;
  NSURLConnection = interface(NSObject) end;
  TNSURLConnection = class(TOCGenericImport<NSURLConnectionClass, NSURLConnection>)  end;

{ TPushWooshThread }

function TPushWooshThread.Quote(Value: String): String;
begin
  Result := '"' + Value.Replace('"', '\"') + '"';
end;

function TPushWooshThread.Send(const Command, Params: String): Boolean;
var
  URL: NSMutableURLRequest;
  Response, ErrorPtr: Pointer;
  Stream: TStringStream;
  Error: String;
  Data: NSData;
  Status: Integer;
begin
  URL := TNSMutableURLRequest.Wrap(TNSMutableURLRequest.Alloc.
    initWithURL(TNSURL.Wrap(TNSURL.OCClass.URLWithString(
    ToNSSTR('https://cp.pushwoosh.com/json/1.3/' + Command)))));
  URL.setHTTPMethod(ToNSSTR('POST'));
  URL.addValue(ToNSSTR('application/json; charset=utf-8'), ToNSSTR('Content-Type'));
  URL.setHTTPBody(ToNSSTR('{"request":{"application":' + Quote(
    FInstance.FApplicationCode) + ',"hwid":' + Quote(GetDeviceUniqueIds[0]) +
    Params + '}}').dataUsingEncoding(NSUTF8StringEncoding));

  Response := nil;
  ErrorPtr := nil;
  Data := TNSURLConnection.OCClass.sendSynchronousRequest(URL, @Response, @ErrorPtr);

  if ErrorPtr = nil then
  begin
    Status := TNSHTTPURLResponse.Wrap(Response).statusCode;
    if Status = 200 then
    begin
      Stream := TStringStream.Create;
      if (Data <> nil) and (Data.length <> 0) then
        Stream.Write(Data.bytes^, Data.length);

      if (Stream.DataString <> '') and not Stream.DataString.Contains('200') then
        Error := 'PushWoosh failure in ' + Command + ': ' + Stream.DataString
      else
        Error := '';
    end else
      Error := FromNSSTR(TNSHTTPURLResponse.OCClass.localizedStringForStatusCode(Status))
  end else
    Error := FromNSSTR(TNSError.Wrap(ErrorPtr).localizedDescription);

  if Error <> '' then
    Synchronize(procedure
    begin
      FInstance.DoError(Error, False);
    end);

  Result := (Error = '');
end;

procedure TPushWooshThread.SendOpen;
begin
  if Send('applicationOpen', '') then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psOpen);
    end);
end;

procedure TPushWooshThread.SendRegister;
begin
  if Send('registerDevice', Format(',"device_type":%d,' +
    '"language":%s,"timezone":%d,"package":%s,"push_token":%s',
    [{$IFDEF IOS}1{$ELSE}7{$ENDIF}, Quote(FromNSSTR(TNSLocale.Wrap(
    TNSLocale.OCClass.currentLocale).localeIdentifier).SubString(0, 2)),
    TNSTimeZone.Wrap(TNSTimeZone.OCClass.localTimeZone).secondsFromGMT,
    Quote(FromNSSTR(TNSBundle.Wrap(TNSBundle.OCClass.mainBundle).
    objectForInfoDictionaryKey(ToNSSTR('CFBundleIdentifier')))),
    Quote(FInstance.FToken)])) then
      FInstance.Critical(procedure
      begin
        Exclude(FInstance.FToSend, psRegister);
      end);
end;

procedure TPushWooshThread.SendTags;
var
  Tags, Data: TArray<String>;
  Index, Inner: Integer;
  SendData: String;
begin
  SendData := '';

  Tags := FInstance.TagList['TJVEPushWoosh__Tags_List'];
  if Tags <> nil then
  begin
    for Index := 0 to Length(Tags) - 1 do
    begin
      Data := Tags[Index].Split(['~']);
      if Length(Data[1]) <> 1 then
        Continue;

      Tags[Index] := Quote(Data[0]) + ':';

      if Data[1] = '*' then
      begin
        Data := FInstance.TagList[Data[0]];
        for Inner := 0 to Length(Data) - 1 do
          Data[Inner] := Quote(Data[Inner]);
        Tags[Index] := Tags[Index] + '[' + String.Join(',', Data) + ']'
      end else
      if Data[1] = '@' then
        Tags[Index] := Tags[Index] + Quote(FInstance.TagString[Data[0]])
      else if Data[1] = '#' then
        Tags[Index] := Tags[Index] + IntToStr(FInstance.TagInteger[Data[0]])
    end;

    SendData := String.Join(',', Tags);
  end;

  if Send('setTags', ',"tags":{' + SendData + '}') then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psTags);
    end);
end;

procedure TPushWooshThread.SendLocation;
var
  Loc: TLocationCoord2D;
  Format: TFormatSettings;
begin
  Format := TFormatSettings.Create;
  Format.DecimalSeparator := '.';

  Loc := FInstance.Location;
  if ((Loc.Latitude = 0) and (Loc.Longitude = 0)) or Send('getNearestZone',
    ',"lat":' + FloatToStr(Loc.Latitude, Format) +
    ',"lng":' + FloatToStr(Loc.Longitude, Format)) then
      FInstance.Critical(procedure
      begin
        Exclude(FInstance.FToSend, psLocation);
      end);
end;

procedure TPushWooshThread.SendStat;
begin
  if Send('pushStat', ',"hash":' + Quote(FInstance.FHash)) then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psStat);
    end);
end;

procedure TPushWooshThread.Execute;
var
  Pool: NSAutoreleasePool;
  ToSend: TJVEPushWooshSends;
  Instance: TJVEPushNotification;
begin
  Pool := TNSAutoreleasePool.Create;
  try
    try
      repeat
        FInstance := nil;
        Sleep(1000);
        Instance := TJVEPushNotification.GlobalInstance;
        if (Instance = nil) or not (Instance is TJVEPushWoosh) then
          Continue;

        FInstance := TJVEPushWoosh(Instance);
        if FInstance.FApplicationCode = '' then
          Continue;

        FInstance.Critical(procedure
        begin
          ToSend := FInstance.FToSend;
        end);

        if ToSend = [] then
          Continue;

        if psOpen in ToSend then
          SendOpen
        else if psRegister in ToSend then
          SendRegister
        else if psTags in ToSend then
          SendTags
        else if psLocation in ToSend then
          SendLocation
        else if psStat in ToSend then
          SendStat;
      until Terminated;
    except
      // This is mostly a statistics job: all exceptions can be silently ignored.
    end;
  finally
    FreeOnTerminate := True;
    Pool.drain;
  end;
end;

{$ELSEIF Defined(ANDROID)}
{$REGION 'java.net.* import'}
type
  JURLConnection      = interface;  // java.net.URLConnection
  JHttpURLConnection  = interface;  // java.net.HttpURLConnection
  JURL                = interface;  // java.net.URL

  JURLConnectionClass = interface(JObjectClass)
  ['{5E9817B4-2DBD-48D9-B702-8E039503AEAE}']
  end;

  [JavaSignature('java/net/URLConnection')]
  JURLConnection = interface(JObject)
  ['{2ECDC807-25F0-4FE3-A1D6-4B1EBB90B6AE}']
    {Methods}
    procedure connect; cdecl;
    procedure setAllowUserInteraction(newValue: Boolean); cdecl;
    procedure setDoInput(newValue: Boolean); cdecl;
    procedure setDoOutput(newValue: Boolean); cdecl;
    procedure setConnectTimeout(timeoutMillis: Integer); cdecl;
    procedure setReadTimeout(timeoutMillis: Integer); cdecl;
    procedure setRequestProperty(key, value: JString); cdecl;
    procedure addRequestProperty(field: JString; newValue: JString); cdecl;
    function getInputStream: JInputStream; cdecl;
    function getOutputStream: JOutputStream; cdecl;
    function getContentEncoding: JString; cdecl;
    function getHeaderField(name: JString): JString; cdecl;
  end;
  TJURLConnection = class(TJavaGenericImport<JURLConnectionClass, JURLConnection>) end;

  JHttpURLConnectionClass = interface(JURLConnectionClass)
  ['{5850F622-ED4F-415E-B3A5-FABBEC857E14}']
    {Property Methods}
    function _GetHTTP_ACCEPTED: Integer;
    function _GetHTTP_BAD_GATEWAY: Integer;
    function _GetHTTP_BAD_METHOD: Integer;
    function _GetHTTP_BAD_REQUEST: Integer;
    function _GetHTTP_CLIENT_TIMEOUT: Integer;
    function _GetHTTP_CONFLICT: Integer;
    function _GetHTTP_CREATED: Integer;
    function _GetHTTP_ENTITY_TOO_LARGE: Integer;
    function _GetHTTP_FORBIDDEN: Integer;
    function _GetHTTP_GATEWAY_TIMEOUT: Integer;
    function _GetHTTP_GONE: Integer;
    function _GetHTTP_INTERNAL_ERROR: Integer;
    function _GetHTTP_LENGTH_REQUIRED: Integer;
    function _GetHTTP_MOVED_PERM: Integer;
    function _GetHTTP_MOVED_TEMP: Integer;
    function _GetHTTP_MULT_CHOICE: Integer;
    function _GetHTTP_NO_CONTENT: Integer;
    function _GetHTTP_NOT_ACCEPTABLE: Integer;
    function _GetHTTP_NOT_AUTHORITATIVE: Integer;
    function _GetHTTP_NOT_FOUND: Integer;
    function _GetHTTP_NOT_IMPLEMENTED: Integer;
    function _GetHTTP_NOT_MODIFIED: Integer;
    function _GetHTTP_OK: Integer;
    function _GetHTTP_PARTIAL: Integer;
    function _GetHTTP_PAYMENT_REQUIRED: Integer;
    function _GetHTTP_PRECON_FAILED: Integer;
    function _GetHTTP_PROXY_AUTH: Integer;
    function _GetHTTP_REQ_TOO_LONG: Integer;
    function _GetHTTP_RESET: Integer;
    function _GetHTTP_SEE_OTHER: Integer;
    function _GetHTTP_SERVER_ERROR: Integer;
    function _GetHTTP_USE_PROXY: Integer;
    function _GetHTTP_UNAUTHORIZED: Integer;
    function _GetHTTP_UNSUPPORTED_TYPE: Integer;
    function _GetHTTP_UNAVAILABLE: Integer;
    function _GetHTTP_VERSION: Integer;

    {Read-only Properties}
    // 2XX: generally "OK"
    // 3XX: relocation/redirect
    // 4XX: client error
    // 5XX: server error

    //Numeric status code, 202: Accepted
    property HTTP_ACCEPTED: Integer read _GetHTTP_ACCEPTED;
    //Numeric status code, 502: Bad Gateway
    property HTTP_BAD_GATEWAY: Integer read _GetHTTP_BAD_GATEWAY;
    // Numeric  status code, 405: Bad Method
    property HTTP_BAD_METHOD: Integer read _GetHTTP_BAD_METHOD;
    // Numeric  status code, 400: Bad Request
    property HTTP_BAD_REQUEST: Integer read _GetHTTP_BAD_REQUEST;
    // Numeric  status code, 408: Client Timeout
    property HTTP_CLIENT_TIMEOUT: Integer read _GetHTTP_CLIENT_TIMEOUT;
    // Numeric  status code, 409: Conflict
    property HTTP_CONFLICT: Integer read _GetHTTP_CONFLICT;
    // Numeric  status code, 201: Created
    property HTTP_CREATED: Integer read _GetHTTP_CREATED;
    // Numeric  status code, 413: Entity too large
    property HTTP_ENTITY_TOO_LARGE: Integer read _GetHTTP_ENTITY_TOO_LARGE;
    // Numeric  status code, 403: Forbidden
    property HTTP_FORBIDDEN: Integer read _GetHTTP_FORBIDDEN;
    // Numeric  status code, 504: Gateway timeout
    property HTTP_GATEWAY_TIMEOUT: Integer read _GetHTTP_GATEWAY_TIMEOUT;
    // Numeric  status code, 410: Gone
    property HTTP_GONE: Integer read _GetHTTP_GONE;
    // Numeric  status code, 500: Internal error
    property HTTP_INTERNAL_ERROR: Integer read _GetHTTP_INTERNAL_ERROR;
    // Numeric  status code, 411: Length required
    property HTTP_LENGTH_REQUIRED: Integer read _GetHTTP_LENGTH_REQUIRED;
    // Numeric  status code, 301 Moved permanently
    property HTTP_MOVED_PERM: Integer read _GetHTTP_MOVED_PERM;
    // Numeric  status code, 302: Moved temporarily
    property HTTP_MOVED_TEMP: Integer read _GetHTTP_MOVED_TEMP;
    // Numeric  status code, 300: Multiple choices
    property HTTP_MULT_CHOICE: Integer read _GetHTTP_MULT_CHOICE;
    // Numeric  status code, 204: No content
    property HTTP_NO_CONTENT: Integer read _GetHTTP_NO_CONTENT;
    // Numeric  status code, 406: Not acceptable
    property HTTP_NOT_ACCEPTABLE: Integer read _GetHTTP_NOT_ACCEPTABLE;
    // Numeric  status code, 203: Not authoritative
    property HTTP_NOT_AUTHORITATIVE: Integer read _GetHTTP_NOT_AUTHORITATIVE;
    // Numeric  status code, 404: Not found
    property HTTP_NOT_FOUND: Integer read _GetHTTP_NOT_FOUND;
    // Numeric  status code, 501: Not implemented
    property HTTP_NOT_IMPLEMENTED: Integer read _GetHTTP_NOT_IMPLEMENTED;
    // Numeric  status code, 304: Not modified
    property HTTP_NOT_MODIFIED: Integer read _GetHTTP_NOT_MODIFIED;
    // Numeric  status code, 200: OK
    property HTTP_OK: Integer read _GetHTTP_OK;
    // Numeric  status code, 206: Partial
    property HTTP_PARTIAL: Integer read _GetHTTP_PARTIAL;
    // Numeric  status code, 402: Payment required
    property HTTP_PAYMENT_REQUIRED: Integer read _GetHTTP_PAYMENT_REQUIRED;
    // Numeric  status code, 412: Precondition failed
    property HTTP_PRECON_FAILED: Integer read _GetHTTP_PRECON_FAILED;
    // Numeric  status code, 407: Proxy authentication required
    property HTTP_PROXY_AUTH: Integer read _GetHTTP_PROXY_AUTH;
    // Numeric  status code, 414: Request too long
    property HTTP_REQ_TOO_LONG: Integer read _GetHTTP_REQ_TOO_LONG;
    // Numeric  status code, 205: Reset
    property HTTP_RESET: Integer read _GetHTTP_RESET;
    // Numeric  status code, 303: See other
    property HTTP_SEE_OTHER: Integer read _GetHTTP_SEE_OTHER;
    // Numeric  status code, 500: Internal error
    // @deprecated Use {@link #HTTP_INTERNAL_ERROR} instead.
    property HTTP_SERVER_ERROR: Integer read _GetHTTP_SERVER_ERROR;
    // Numeric  status code, 305: Use proxy.
    //
    // <p>Like Firefox and Chrome, this class doesn't honor this response code.
    // Other implementations respond to this status code by retrying the request
    // using the HTTP proxy named by the response's Location header field.
    property HTTP_USE_PROXY: Integer read _GetHTTP_USE_PROXY;
    // Numeric  status code, 401: Unauthorized
    property HTTP_UNAUTHORIZED: Integer read _GetHTTP_UNAUTHORIZED;
    // Numeric  status code, 415: Unsupported type
    property HTTP_UNSUPPORTED_TYPE: Integer read _GetHTTP_UNSUPPORTED_TYPE;
    // Numeric  status code, 503: Unavailable
    property HTTP_UNAVAILABLE: Integer read _GetHTTP_UNAVAILABLE;
    // Numeric status code, 505: Version not supported
    property HTTP_VERSION: Integer read _GetHTTP_VERSION;
  end;

  [JavaSignature('java/net/HttpURLConnection')]
  JHttpURLConnection = interface(JURLConnection)
  ['{6FF4A4B0-A79E-4852-8938-30C61E279F52}']
    {Methods}
    procedure disconnect; cdecl;
    procedure setRequestMethod(method: JString); cdecl;
    function getResponseCode: Integer; cdecl;
    function getResponseMessage: JString; cdecl;
    function getRequestMethod(): JString; cdecl;
    function getErrorStream: JInputStream; cdecl;
  end;
  TJHttpURLConnection = class(TJavaGenericImport<JHttpURLConnectionClass, JHttpURLConnection>) end;

  JURLClass = interface(JObjectClass)
  ['{246FE844-A842-44F5-B0A3-43A8C5ED8091}']
      {Constructors}
    function init(spec: JString): JURL; cdecl; overload;
    function init(context: JURL; spec: JString): JURL; cdecl; overload;
  end;

  [JavaSignature('java/net/URL')]
  JURL = interface(JObject)
  ['{1C4C1873-65AE-4722-8EEF-36BBF423C9C5}']
    {Methods}
    function openConnection: JURLConnection; cdecl;
  end;
  TJURL = class(TJavaGenericImport<JURLClass, JURL>) end;
{$ENDREGION}


{ TPushWooshThread }

function TPushWooshThread.Quote(Value: String): String;
begin
  Result := '"' + Value.Replace('"', '\"') + '"';
end;

function TPushWooshThread.Send(const Command, Params: String): Boolean;
var
  URL: JHttpURLConnection;
  Body, Error: String;
  Buffer: TJavaArray<Byte>;
  Stream: TStringStream;
  Input: JInputStream;
const
  ServiceURL = 'https://cp.pushwoosh.com/json/1.3/';
begin
  Error := '';

  URL := TJHttpURLConnection.Wrap((TJURL.JavaClass.init(StringToJString(
    ServiceURL + Command)).openConnection as ILocalObject).GetObjectID);
  URL.setRequestMethod(StringToJString('POST'));
  URL.setDoOutput(True);
  try
    Body := '{"request":{"application":' + Quote(FInstance.FApplicationCode) +
      ',"hwid":' + Quote(GetDeviceUniqueIds[0]) + Params + '}}';
    URL.addRequestProperty(StringToJString('Content-Type'),
      StringToJString('application/json; charset=utf-8'));
    URL.addRequestProperty(StringToJString('Content-Length'),
      TJInteger.JavaClass.toString(Length(Body)));
    URL.getOutputStream.write(StringToJString(Body).getBytes(StringToJString('UTF8')));

    URL.connect;
    if URL.getResponseCode = TJHttpURLConnection.JavaClass.HTTP_OK then
    begin
      Input := URL.getInputStream;
      Stream := TStringStream.Create;
      Stream.Position := 0;
      Buffer := TJavaArray<Byte>.Create(1024);
      Stream.WriteData(Buffer.Data, Input.read(Buffer, 0, 1024));
      Input.close;

      if (Stream.DataString <> '') and not Stream.DataString.Contains('200') then
        Error := 'PushWoosh failure in ' + Command + ': ' + Stream.DataString;
    end else
      Error := JStringToString(URL.getResponseMessage);
  finally
    try
      URL.disconnect;
    except
    end;
  end;

  if Error <> '' then
    Synchronize(procedure
    begin
      FInstance.DoError(Error, False);
    end);

  Result := (Error = '');
end;

procedure TPushWooshThread.SendOpen;
begin
  if Send('applicationOpen', '') then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psOpen);
    end);
end;

procedure TPushWooshThread.SendRegister;
begin
  if Send('registerDevice', Format(',"device_type":3,' +
    '"language":%s,"timezone":%d,"package":%s,"push_token":%s',
    [Quote(JStringToString(TJLocale.JavaClass.getDefault.getLanguage)),
    // new Date() - creates object with current date/time in UTC:
    Round(TJTimeZone.JavaClass.getDefault.getOffset(TJDate.JavaClass.init.getTime) / 1000),
    Quote(JStringToString(GetSharedActivityContext.getPackageName)),
    Quote(FInstance.FToken)])) then
      FInstance.Critical(procedure
      begin
        Exclude(FInstance.FToSend, psRegister);
      end);
end;

procedure TPushWooshThread.SendTags;
var
  Tags, Data: TArray<String>;
  Index, Inner: Integer;
  SendData: String;
begin
  SendData := '';

  Tags := FInstance.TagList['TJVEPushWoosh__Tags_List'];
  if Tags <> nil then
  begin
    for Index := 0 to Length(Tags) - 1 do
    begin
      Data := Tags[Index].Split(['~']);
      if Length(Data[1]) <> 1 then
        Continue;

      Tags[Index] := Quote(Data[0]) + ':';

      if Data[1] = '*' then
      begin
        Data := FInstance.TagList[Data[0]];
        for Inner := 0 to Length(Data) - 1 do
          Data[Inner] := Quote(Data[Inner]);
        Tags[Index] := Tags[Index] + '[' + String.Join(',', Data) + ']'
      end else
      if Data[1] = '@' then
        Tags[Index] := Tags[Index] + Quote(FInstance.TagString[Data[0]])
      else if Data[1] = '#' then
        Tags[Index] := Tags[Index] + IntToStr(FInstance.TagInteger[Data[0]])
    end;

    SendData := String.Join(',', Tags);
  end;

  if Send('setTags', ',"tags":{' + SendData + '}') then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psTags);
    end);
end;

procedure TPushWooshThread.SendLocation;
var
  Loc: TLocationCoord2D;
  Format: TFormatSettings;
begin
  Format := TFormatSettings.Create;
  Format.DecimalSeparator := '.';

  Loc := FInstance.Location;
  if ((Loc.Latitude = 0) and (Loc.Longitude = 0)) or Send('getNearestZone',
    ',"lat":' + FloatToStr(Loc.Latitude, Format) +
    ',"lng":' + FloatToStr(Loc.Longitude, Format)) then
      FInstance.Critical(procedure
      begin
        Exclude(FInstance.FToSend, psLocation);
      end);
end;

procedure TPushWooshThread.SendStat;
begin
  if Send('pushStat', ',"hash":' + Quote(FInstance.FHash)) then
    FInstance.Critical(procedure
    begin
      Exclude(FInstance.FToSend, psStat);
    end);
end;

procedure TPushWooshThread.Execute;
var
  ToSend: TJVEPushWooshSends;
  Instance: TJVEPushNotification;
begin
  try
    try
      repeat
        FInstance := nil;
        Sleep(1000);
        Instance := TJVEPushNotification.GlobalInstance;
        if (Instance = nil) or not (Instance is TJVEPushWoosh) then
          Continue;

        FInstance := TJVEPushWoosh(Instance);
        if FInstance.FApplicationCode = '' then
          Continue;

        FInstance.Critical(procedure
        begin
          ToSend := FInstance.FToSend;
        end);

        if ToSend = [] then
          Continue;

        if psOpen in ToSend then
          SendOpen
        else if psRegister in ToSend then
          SendRegister
        else if psTags in ToSend then
          SendTags
        else if psLocation in ToSend then
          SendLocation
        else if psStat in ToSend then
          SendStat;
      until Terminated;
    except
      // This is mostly a statistics job: all exceptions can be silently ignored.
    end;
  finally
    FreeOnTerminate := True;
  end;
end;

{$ENDIF}

const
  TagNameSuffixes: array[TJVEPushWooshTagType] of String = ('~*', '~@', '~#');
  TagsPrefix = 'TJVEPushWoosh_';
  TagsList = '_Tags_List';

{ TJVEPushWoosh }

constructor TJVEPushWoosh.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FProtected := TCriticalSection.Create;
  {$IF Defined(MACOS) or Defined(ANDROID)}
  if PushWooshThread = nil then
    PushWooshThread := TPushWooshThread.Create;
  {$ENDIF}
end;

destructor TJVEPushWoosh.Destroy;
begin
  FreeAndNil(FProtected);
  {$IF Defined(MACOS) or Defined(ANDROID)}
  if PushWooshThread <> nil then
    FreeAndNil(PushWooshThread);
  {$ENDIF}
  inherited Destroy;
end;

procedure TJVEPushWoosh.Critical(Proc: TProc);
begin
  FProtected.Enter;
  try
    Proc;
  finally
    FProtected.Leave;
  end;
end;

procedure TJVEPushWoosh.AfterConstruction;
begin
  inherited AfterConstruction;
end;

procedure TJVEPushWoosh.DeleteTag(Name: String);
var
  Tags: TArray<String>;
  Idx: Integer;
begin
  Tags := TagList[TagsPrefix + TagsList];

  Idx := IndexStr(Name + TagNameSuffixes[ttList], Tags);
  if Idx = -1 then
    Idx := IndexStr(Name + TagNameSuffixes[ttString], Tags);
  if Idx = -1 then
    Idx := IndexStr(Name + TagNameSuffixes[ttInteger], Tags);

  if Idx <> -1 then
  begin
    Tags[Idx] := Tags[Length(Tags) - 1];
    SetLength(Tags, Length(Tags) - 1);
    TagList[TagsPrefix + TagsList] := Tags;
  end;

  Critical(procedure
  begin
    Include(FToSend, psTags);
  end);
end;

procedure TJVEPushWoosh.DoReceived(Push: TJVEPushData; OnAppStart: Boolean);
begin
  inherited DoReceived(Push, OnAppStart);

  Critical(procedure
  begin
    FHash := Push.GetHash;
    if FHash <> '' then
      Include(FToSend, psStat);
  end);
end;

procedure TJVEPushWoosh.PresentPush(Push: TJVEPushData);
var
  Link: String;
begin
  Link := Trim(Push.GetLink);
  if Link = '' then
    inherited PresentPush(Push)
  else
    ShowConfirmation(Push.GetMessage, procedure(Confirmed: Boolean)
    begin
      if Confirmed then
        TJVEOpenURL.OpenURL(Link);
    end);
end;

procedure TJVEPushWoosh.DoToken(Token: String);
begin
  inherited DoToken(Token);
  Critical(procedure
  begin
    FToken := Token.Replace('<', '').Replace(' ', '').Replace('>', '');
    if FApplicationCode <> '' then
      FToSend := [psOpen, psRegister, psTags, psLocation];
  end);
end;

function TJVEPushWoosh.GetTagInteger(Name: String): Integer;
begin
  Result := TJVEConfiguration.ReadInteger(TagsPrefix + Name, 0);
end;

function TJVEPushWoosh.GetTagList(Name: String): TArray<String>;
var
  List: TStringList;
begin
  List := TStringList.Create;
  try
    List.CommaText := TagString[Name];
    Result := List.ToStringArray;
  finally
    FreeAndNil(List);
  end;
end;

function TJVEPushWoosh.GetTagString(Name: String): String;
begin
  Result := TJVEConfiguration.ReadString(TagsPrefix + Name, '');
end;

function TJVEPushWoosh.GetUserLocation: TLocationCoord2D;
begin
  Result.Latitude := TJVEConfiguration.ReadFloat(TagsPrefix + '_Location_Latitude', 0);
  Result.Longitude := TJVEConfiguration.ReadFloat(TagsPrefix + '_Location_Longitude', 0);
end;

procedure TJVEPushWoosh.SetApplicationCode(const Value: String);
begin
  Critical(procedure
  begin
    FApplicationCode := Value;
    if FToken <> '' then
      Include(FToSend, psRegister);
  end);
end;

procedure TJVEPushWoosh.SetTagInteger(Name: String; const Value: Integer);
begin
  TJVEConfiguration.WriteInteger(TagsPrefix + Name, Value);
  UpdateTag(Name, ttInteger);
end;

procedure TJVEPushWoosh.SetTagList(Name: String; const Value: TArray<String>);
var
  List: TStringList;
begin
  List := TStringList.Create;
  try
    List.AddStrings(Value);
    TJVEConfiguration.WriteString(TagsPrefix + Name, List.CommaText);
    UpdateTag(Name, ttList);
  finally
    FreeAndNil(List);
  end;
end;

procedure TJVEPushWoosh.SetTagString(Name: String; const Value: String);
begin
  TJVEConfiguration.WriteString(TagsPrefix + Name, Value);
  UpdateTag(Name, ttString);
end;

procedure TJVEPushWoosh.SetUserLocation(const Value: TLocationCoord2D);
begin
  TJVEConfiguration.WriteFloat(TagsPrefix + '_Location_Latitude', Value.Latitude);
  TJVEConfiguration.WriteFloat(TagsPrefix + '_Location_Longitude', Value.Longitude);

  Critical(procedure
  begin
    Include(FToSend, psLocation);
  end);
end;

procedure TJVEPushWoosh.UpdateTag(Name: String; Kind: TJVEPushWooshTagType);
var
  Tags: TArray<String>;
  Target: Integer;
begin
  if Name = TagsPrefix + TagsList then
    Exit;

  Tags := TagList[TagsPrefix + TagsList];
  if not MatchStr(Name + TagNameSuffixes[Kind], Tags) then
  begin
    Target := IndexStr(Name + TagNameSuffixes[ttList], Tags);
    if Target = -1 then
    begin
      Target := IndexStr(Name + TagNameSuffixes[ttString], Tags);
      if Target = -1 then
      begin
        Target := IndexStr(Name + TagNameSuffixes[ttInteger], Tags);
        if Target = -1 then
        begin
          Target := Length(Tags);
          SetLength(Tags, Target + 1);
        end;
      end;
    end;

    Tags[Target] := Name + TagNameSuffixes[Kind];
    TagList[TagsPrefix + TagsList] := Tags;
  end;

  Critical(procedure
  begin
    Include(FToSend, psTags);
  end);
end;

{ TJVEPushWooshData }

function TJVEPushWooshData.GetCustomData: String;
begin
  Result := Values['u'];
end;

function TJVEPushWooshData.GetHash: String;
begin
  Result := Values['p'];
end;

function TJVEPushWooshData.GetLink: String;
begin
  Result := Values['l'];
end;

end.

